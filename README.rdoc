= Sinatra

Sinatraは最小限の記述で素早くWebアプリケーションを記述するためのRubyによるDSLです:

  # myapp.rb
  require 'rubygems'
  require 'sinatra'
  get '/' do
    'Hello world!'
  end

Gemをインストールして以下のように実行します:

  sudo gem install sinatra
  ruby myapp.rb

http://localhost:4567 にアクセスすることによって動作を確認できます

== Routes

RouteはHTTPメソッドと対になったURLにマッチするパターンです
それぞれのルートはブロックをともないます:

  get '/' do
    .. 何かを表示 ..
  end

  post '/' do
    .. 何かを作成 ..
  end

  put '/' do
    .. 何かを更新 ..
  end

  delete '/' do
    .. 何かを削除 ..
  end

Routeは定義された順にマッチングが行われ、
最初にマッチしたものが実行されます

Routeパターンは名前付きパラメータを持つことができ、それらには
<tt>params</tt>ハッシュによってアクセスできます:

  get '/hello/:name' do
    # "GET /foo" や "GET /bar" にマッチする
    # params[:name] は 'foo' か 'bar' が格納されている
    "Hello #{params[:name]}!"
  end

また、ブロック引数としても取得することもできます:

  get '/hello/:name' do |n|
    "Hello #{n}!"
  end

Routeパターンはsplat(ワイルドカード)パラメータを持つことができ、
配列<tt>params['splat']</tt>によってアクセスできます

  get '/say/*/to/*' do
    # /say/hello/to/world にマッチする
    params[:splat] # => ["hello", "world"]
  end

  get '/download/*.*' do
    # /download/path/to/file.xml にマッチする
    params[:splat] # => ["path/to/file", "xml"]
  end

正規表現によるマッチも可能です

  get %r{/hello/([\w]+)} do
    "Hello, #{params[:captures].first}!"
  end

ブロック引数によってアクセスできます:

  get %r{/hello/([\w]+)} do |c|
    "Hello, #{c}!"
  end

Routeにはマッチングに使用するいくつかの状態を指定してすることができます.
例えばユーザエージェントを指定して:

  get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
    "あなたは Songbird version #{params[:agent][0]} を利用しています"
  end

  get '/foo' do
    # Songbird以外のブラウザにマッチ
  end

== Static Files

静的なファイルは<tt>./public</tt>ディレクトリから提供されます. <tt>:public</tt>
オプションを指定することによって任意のディレクトリを指定することもできます:

  set :public, File.dirname(__FILE__) + '/static'

注意すべき点として、パブリックディレクトリの名前はURLに含まれません.
つまり<tt>./public/css/style.css</tt>というファイルは
<tt>http://example.com/css/style.css</tt> として公開されます.

== Views / Templates

Templates are assumed to be located directly under the <tt>./views</tt>
directory. To use a different views directory:

  set :views, File.dirname(__FILE__) + '/templates'

One important thing to remember is that you always have to reference
templates with symbols, even if they're in a subdirectory (in this
case use <tt>:'subdir/template'</tt>). Rendering methods will render
any strings passed to them directly.

=== Haml Templates

The haml gem/library is required to render HAML templates:

  ## You'll need to require haml in your app
  require 'haml'

  get '/' do
    haml :index
  end

Renders <tt>./views/index.haml</tt>.

{Haml's options}[http://haml.hamptoncatlin.com/docs/rdoc/classes/Haml.html]
can be set globally through Sinatra's configurations,
see {Options and Configurations}[http://www.sinatrarb.com/configuration.html],
and overridden on an individual basis.

  set :haml, {:format => :html5 } # default Haml format is :xhtml

  get '/' do
    haml :index, :haml_options => {:format => :html4 } # overridden
  end


=== Erb Templates

  ## You'll need to require erb in your app
  require 'erb'

  get '/' do
    erb :index
  end

Renders <tt>./views/index.erb</tt>

=== Builder Templates

The builder gem/library is required to render builder templates:

  ## You'll need to require builder in your app
  require 'builder'

  get '/' do
    content_type 'application/xml', :charset => 'utf-8'
    builder :index
  end

Renders <tt>./views/index.builder</tt>.

=== Sass Templates

The sass gem/library is required to render Sass templates:

  ## You'll need to require haml or sass in your app
  require 'sass'

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet
  end

Renders <tt>./views/stylesheet.sass</tt>.

{Sass' options}[http://haml.hamptoncatlin.com/docs/rdoc/classes/Sass.html]
can be set globally through Sinatra's configurations,
see {Options and Configurations}[http://www.sinatrarb.com/configuration.html],
and overridden on an individual basis.

  set :sass, {:style => :compact } # default Sass style is :nested

  get '/stylesheet.css' do
    content_type 'text/css', :charset => 'utf-8'
    sass :stylesheet, :sass_options => {:style => :expanded } # overridden
  end


=== Inline Templates

  get '/' do
    haml '%div.title Hello World'
  end

Renders the inlined template string.

=== Accessing Variables in Templates

Templates are evaluated within the same context as route handlers. Instance
variables set in route handlers are direcly accessible by templates:

  get '/:id' do
    @foo = Foo.find(params[:id])
    haml '%h1= @foo.name'
  end

Or, specify an explicit Hash of local variables:

  get '/:id' do
    foo = Foo.find(params[:id])
    haml '%h1= foo.name', :locals => { :foo => foo }
  end

This is typically used when rendering templates as partials from within
other templates.

=== In-file Templates

Templates may be defined at the end of the source file:

  require 'rubygems'
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Hello world!!!!!

NOTE: In-file templates defined in the source file that requires sinatra
are automatically loaded. Call the <tt>use_in_file_templates!</tt>
method explicitly if you have in-file templates in other source files.

=== Named Templates

Templates may also be defined using the top-level <tt>template</tt> method:

  template :layout do
    "%html\n  =yield\n"
  end

  template :index do
    '%div.title Hello World!'
  end

  get '/' do
    haml :index
  end

If a template named "layout" exists, it will be used each time a template
is rendered. You can disable layouts by passing <tt>:layout => false</tt>.

  get '/' do
    haml :index, :layout => !request.xhr?
  end

== Helpers

<tt>helpers</tt>メソッドを使うことによって、Routeハンドラや
テンプレートで利用できるhelperメソッドを定義できます:

  helpers do
    def bar(name)
      "#{name}bar"
    end
  end

  get '/:name' do
    bar(params[:name])
  end

== Filters

Before filterは各リクエストを評価する前に、そのリクエストのコンテキストにおいて
実行され、任意の処理を行ったりrequestやresponseを修正することが可能です
Before filterにおいて定義したインスタンス変数はテンプレートや、ルートからアクセスできます:

  before do
    @note = 'Hi!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=> 'Hi!'
    params[:splat] #=> 'bar/baz'
  end

== Halting

以下のようにしてBefore filterやRouteの処理中にリクエストを直ちに
中止することができます:

  halt

また、レスポンスのbodyを指定することもできます

  halt 'ここがbodyになります'

さらにステータスコードを指定することも出来ます

  halt 401, 'あっちへ行け！'

== Passing

<tt>pass</tt>を使うことでrouteは次のrouteへ処理をゆだねることができる

  get '/guess/:who' do
    pass unless params[:who] == 'Frank'
    "みつかった！"
  end

  get '/guess/*' do
    "残念でした"
  end

routeは直ちに処理を中止して次にマッチしたrouteに処理を移します
もしマッチするrouteが見つからなかった場合は404が返されます

== Configuration

以下はSinatraを起動したときに、実行環境によらず一度だけ実行されます:

  configure do
    ...
  end

以下は実行環境(環境変数RACK_ENVの値）が<tt>:production</tt>に設定されている
ときだけ実行されます:

  configure :production do
    ...
  end

以下は<tt>:production</tt>もしくは<tt>:test</tt>の時に実行されます

  configure :production, :test do
    ...
  end

== Error handling

エラーハンドラはRouteやBefore filterと同じコンテキストで実行されます. これは
必要とされるすべての機能、たとえば<tt>haml</tt>や<tt>erb</tt>、<tt>halt</tt>
などを利用できるということです:

=== Not Found

例外<tt>Sinatra::NotFound</tt>が発生するか、レスポンスのステータスコードが404だった場合は
<tt>not_found</tt>ハンドラが呼び出されます:

  not_found do
    'ファイルが見つかりませんでした'
  end

=== Error

+error+ ハンドラは、RouteかBefore filterで例外が発生したときに呼び出されます.
例外オブジェクトは<tt>sinatra.error</tt>Rack環境変数から取得できます:

  error do
    'すみません　手に負えないエラーが発生しました - ' + env['sinatra.error'].name
  end

Custom errors:

  error MyCustomError do
    'おっと、いま起こったのは...' + request.env['sinatra.error'].message
  end

このとき、以下のように例外が発生すると:

  get '/' do
    raise MyCustomError, 'なにかの間違い'
  end

このようなメッセージを見ることができます:

  おっと、いま起こったのは... 何かの間違い

Sinatraはdevelopment環境で実行したときだけ、特別な<tt>not_found</tt>と<tt>error</tt>
ハンドラを用意します

== Mime types

<tt>send_file</tt>を使用したとき、Sinatraは静的ファイルのMIMEタイプをあなたが
期待するようには理解できません. +mime+メソッドを使ってファイルの拡張子を登録してください:

  mime :foo, 'text/foo'

== Rack Middleware

Sinatra rides on Rack[http://rack.rubyforge.org/], a minimal standard
interface for Ruby web frameworks. One of Rack's most interesting capabilities
for application developers is support for "middleware" -- components that sit
between the server and your application monitoring and/or manipulating the
HTTP request/response to provide various types of common functionality.

Sinatra makes building Rack middleware pipelines a cinch via a top-level
+use+ method:

  require 'sinatra'
  require 'my_custom_middleware'

  use Rack::Lint
  use MyCustomMiddleware

  get '/hello' do
    'Hello World'
  end

The semantics of +use+ are identical to those defined for the
Rack::Builder[http://rack.rubyforge.org/doc/classes/Rack/Builder.html] DSL
(most frequently used from rackup files). For example, the +use+ method
accepts multiple/variable args as well as blocks:

  use Rack::Auth::Basic do |username, password|
    username == 'admin' && password == 'secret'
  end

Rack is distributed with a variety of standard middleware for logging,
debugging, URL routing, authentication, and session handling. Sinatra uses
many of of these components automatically based on configuration so you
typically don't have to +use+ them explicitly.

== Testing

Sinatra::TestミックスインとSinatra::TestHarnessクラスはSinatraアプリケーション
のテストに利用できる豊富なヘルパーメソッドを用意しています:

  require 'my_sinatra_app'
  require 'test/unit'
  require 'sinatra/test'

  class MyAppTest < Test::Unit::TestCase
    include Sinatra::Test

    def test_my_default
      get '/'
      assert_equal 'Hello World!', @response.body
    end

    def test_with_params
      get '/meet', {:name => 'Frank'}
      assert_equal 'Hello Frank!', @response.body
    end

    def test_with_rack_env
      get '/', {}, :agent => 'Songbird'
      assert_equal "You're using Songbird!", @response.body
    end
  end

さらに http://www.sinatrarb.com/testing.html にSinatra::Testを使った例や、RSpecや
Bacon, test/specのような他のテストフレームワークを利用した例があります

== Command line

Sinatraで作成したアプリケションは直接起動することができます:

  ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-s HANDLER]

以下のようなコマンドラインオプションが利用できます:

  -h # ヘルプを表示
  -p # 使用するポートを指定 (デフォルト 4567)
  -e # 実行環境を指定 (デフォルト development)
  -s # 使用するサーバ／ハンドラを指定 (デフォルト thin)
  -x # Mutexによるロックを使用する (デフォルト off)

== The Bleeding Edge

もしあなたがSinatraの最新のコードを利用したければ、以下のようにローカルに
最新のリポジトリをcloneして、<tt>sinatra/lib</tt>を<tt>LOAD_PATH</tt>に
に加えた上でアプリケーションを実行してください:

  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb

また以下のようにして、あなたのアプリケーションの中で<tt>LOAD_PATH</tt>
を指定することができます:

  $LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
  require 'rubygems'
  require 'sinatra'

  get '/about' do
    "I'm running version " + Sinatra::VERSION
  end

Sinatraのソースを最新のものにするには以下のようにします:

  cd myproject/sinatra
  git pull

== More

* {Project Website}[http://sinatra.github.com/] - Additional documentation,
  news, and links to other resources.
* {Contributing}[http://sinatra.github.com/contributing.html] - Find a bug? Need
  help? Have a patch?
* {Lighthouse}[http://sinatra.lighthouseapp.com] - Issue tracking and release
  planning.
* {Twitter}[http://twitter.com/sinatra]
* {Mailing List}[http://groups.google.com/group/sinatrarb]
* {IRC: #sinatra}[irc://chat.freenode.net/#sinatra] on http://freenode.net
